#!/usr/bin/env python3
'''
åŒ—äº¬å¸ˆèŒƒå¤§å­¦æ ¡å›­ç½‘å‘½ä»¤è¡Œå®¢æˆ·ç«¯
BNU CERNET Command Line Client

Version: 0.1.0
Author: Zhaoji Wang <zhaoji.wang@mail.bnu.edu.cn>
Last Update: July 3, 2023
'''

import argparse
import ctypes
import getpass
import hashlib
import hmac
import json
import math
import re
import sys
import time
from base64 import b64encode
from getpass import getpass
from html.parser import HTMLParser
# from typing import Any, Literal, TypedDict, cast
from urllib.error import URLError
from urllib.parse import urlencode, urljoin
from urllib.request import HTTPRedirectHandler, build_opener, urlopen

VERSION = '0.1.0'

# ANSI escape codes for text colors
GREEN = '\033[92m'
RED = '\033[91m'
YELLOW = '\033[93m'
RESET = '\033[0m'

# å¦‚æœæ˜¯ Windowsï¼Œå¯ç”¨ ANSI escape codes
if sys.platform == 'win32':
    kernel32 = ctypes.windll.kernel32
    kernel32.SetConsoleMode(kernel32.GetStdHandle(-11), 7)

HOST = 'http://gw.bnu.edu.cn'
PORTAL_URL = HOST
API_STATUS_URL = HOST + '/cgi-bin/rad_user_info'
API_TOKEN_URL = HOST + '/cgi-bin/get_challenge'
API_RUN_URL = HOST + '/cgi-bin/srun_portal'
FAKE_CALLBACK_NAME = 'fakeCallback'


class TokenRetrievalError(Exception):
    '''è·å– Token å¤±è´¥çš„é”™è¯¯'''
    pass


class AuthError(Exception):
    '''è®¤è¯å¤±è´¥çš„é”™è¯¯'''
    pass


class StatusError(Exception):
    '''è·å–çŠ¶æ€å¤±è´¥çš„é”™è¯¯'''
    pass


# class ConfigPortal(TypedDict):
#     AuthIP: str
#     AuthIP6: str
#     ServiceIP: str
#     DoubleStackPC: bool
#     DoubleStackMobile: bool
#     AuthMode: bool
#     CloseLogout: bool
#     MacAuth: bool
#     RedirectUrl: bool
#     OtherPCStack: str
#     OtherMobileStack: str
#     MsgApi: str
#     PublicSuccessPages: bool
#     TrafficCarry: int
#     UserAgreeSwitch: bool
#     DialSwitch: bool
#     MultiAuthSwitch: bool

# class ConfigPriceList(TypedDict):
#     Prices: str
#     Default: str
#     BalanceWarning: str

# class Config(TypedDict):
#     '''é…ç½®ä¿¡æ¯

#     ä» HTML ä¸­è§£æ `<script>` å­—æ®µä¸­çš„ `CONFIG` å˜é‡å¾—åˆ°ã€‚
#     '''
#     page: str
#     acid: str
#     ip: str
#     nas: str
#     mac: str
#     url: str
#     lang: str
#     isIPV6: bool
#     portal: ConfigPortal
#     notice: str
#     priceList: ConfigPriceList

# class UserDevice(TypedDict):
#     '''ç”¨æˆ·è®¾å¤‡ä¿¡æ¯'''
#     device: str
#     platform: str

# class UserInfo(TypedDict):
#     '''ç”¨æˆ·ä¿¡æ¯'''
#     ip: str
#     mac: str
#     domain: str
#     username: str
#     password: str

# class PortalInfo(TypedDict):
#     '''Portal ä¿¡æ¯'''
#     nasIp: str
#     lang: str
#     acid: str
#     flowMode: int
#     nowType: str
#     ipv4: str
#     ipv6: str
#     doub: bool
#     userDevice: UserDevice
#     selfServiceIp: str
#     noticeType: str

# class APITokenResponse(TypedDict):
#     '''è·å– Token çš„å“åº”'''
#     challenge: str
#     client_ip: str
#     ecode: int
#     error: str
#     error_msg: str
#     expire: str
#     online_ip: str
#     res: str
#     srun_ver: str
#     st: int

# class APIRunQueryDictLogin(TypedDict):
#     '''è®¤è¯è¯·æ±‚çš„ Query å‚æ•°'''
#     action: Literal['login']
#     username: str
#     password: str
#     os: str
#     name: str
#     double_stack: int
#     chksum: str
#     info: str
#     ac_id: str
#     ip: str
#     n: int
#     type: int

# class APIRunQueryDictLogout(TypedDict):
#     '''æ³¨é”€è¯·æ±‚çš„ Query å‚æ•°'''
#     action: Literal['logout']
#     username: str
#     ip: str
#     ac_id: str

# class APIAuthResponseCommon(TypedDict):
#     '''è®¤è¯å“åº”çš„å…¬å…±éƒ¨åˆ†'''
#     client_ip: str
#     ecode: int
#     error: str
#     srun_ver: str

# class APIAuthResponseLoginOk(APIAuthResponseCommon):
#     '''è®¤è¯å“åº”çš„ç™»å½•æˆåŠŸéƒ¨åˆ†'''
#     ServerFlag: int
#     ServicesIntfServerIP: str
#     ServicesIntfServerPort: str
#     access_token: str
#     checkout_date: int
#     error_msg: str
#     online_ip: str
#     ploy_msg: str
#     real_name: str
#     remain_flux: int
#     remain_times: int
#     res: str
#     suc_msg: str
#     sysver: str
#     username: str
#     wallet_balance: int

# class APIAuthResponseIpAlreadyOnlineError(APIAuthResponseCommon):
#     '''è®¤è¯å“åº”çš„ IP å·²åœ¨çº¿éƒ¨åˆ†'''
#     ServerFlag: int
#     ServicesIntfServerIP: str
#     ServicesIntfServerPort: str
#     access_token: str
#     checkout_date: int
#     error_msg: str
#     online_ip: str
#     real_name: str
#     remain_flux: int
#     remain_times: int
#     res: str
#     suc_msg: str
#     sysver: str
#     username: str
#     wallet_balance: int

# class APIAuthResponseLoginError(APIAuthResponseCommon):
#     '''è®¤è¯å“åº”çš„ç™»å½•å¤±è´¥éƒ¨åˆ†'''
#     error_msg: str
#     online_ip: str
#     res: str
#     st: int

# class APIStatusResponseOnline(TypedDict):
#     '''è·å–çŠ¶æ€çš„å“åº”ï¼ˆåœ¨çº¿ï¼‰'''
#     ServerFlag: int
#     add_time: int
#     all_bytes: int
#     billing_name: str
#     bytes_in: int
#     bytes_out: int
#     checkout_date: int
#     domain: str
#     error: str
#     group_id: str
#     keepalive_time: int
#     online_device_detail: str
#     online_device_total: str
#     online_ip: str
#     online_ip6: str
#     package_id: str
#     pppoe_dial: str
#     products_id: str
#     products_name: str
#     real_name: str
#     remain_bytes: int
#     remain_seconds: int
#     sum_bytes: int
#     sum_seconds: int
#     sysver: str
#     user_balance: float
#     user_charge: int
#     user_mac: str
#     user_name: str
#     wallet_balance: float

# class APIStatusResponseOffline(TypedDict):
#     '''è·å–çŠ¶æ€çš„å“åº”ï¼ˆç¦»çº¿ï¼‰'''
#     client_ip: str
#     ecode: int
#     error: str
#     error_msg: str
#     online_ip: str
#     res: str
#     srun_ver: str
#     st: int

# class APILogoutResponse(TypedDict):
#     '''æ³¨é”€çš„å“åº”'''
#     client_ip: str
#     ecode: int
#     error: str
#     error_msg: str
#     online_ip: str
#     res: str
#     srun_ver: str


class Utils:
    '''The utility class'''

    @staticmethod
    # def query_dict_to_string(params: 'dict[str, Any] | TypedDict') -> str:
    def query_dict_to_string(params):  # type: (dict) -> str
        return urlencode({'callback': FAKE_CALLBACK_NAME, **params, '_': Utils.get_js_timestamp()})

    @staticmethod
    # def get_js_timestamp() -> int:
    def get_js_timestamp():  # type: () -> int
        return int(time.time() * 1000)

    @staticmethod
    # def get_formatted_date_and_time() -> str:
    def get_formatted_date_and_time():  # type: () -> str
        return time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))

    @staticmethod
    # def md5(password: str, token: str) -> str:
    def md5(password, token):  # type: (str, str) -> str
        return hmac.new(token.encode(), password.encode(), hashlib.md5).hexdigest()

    @staticmethod
    # def encode_user_info(info: dict, token: str) -> str:
    def encode_user_info(info, token):  # type: (dict, str) -> str

        # def encode(msg: str, key: str):
        def encode(msg, key):  # type: (str, str) -> str

            # def sencode(msg: str, key: bool) -> 'list[int]':
            def sencode(msg, key):  # type: (str, bool) -> 'list[int]'

                # def ordat(msg: str, idx: int) -> int:
                def ordat(msg, idx):  # type: (str, int) -> int
                    return ord(msg[idx]) if len(msg) > idx else 0

                l = len(msg)
                # pwd: 'list[int]' = []
                pwd = []  # type: list[int]
                for i in range(0, l, 4):
                    pwd.append(
                        ordat(msg, i) | ordat(msg, i + 1) << 8 | ordat(msg, i + 2) << 16 | ordat(msg, i + 3) << 24)
                if key:
                    pwd.append(l)
                return pwd

            # def lencode(msg: 'list[int]', key: bool) -> 'str | None':
            def lencode(msg, key):  # type: ('list[int]', bool) -> 'str | None'
                l = len(msg)
                ll = (l - 1) << 2
                if key:
                    m = msg[l - 1]
                    if m < ll - 3 or m > ll:
                        return
                    ll = m
                msg_chars = [
                    chr(msg[i] & 0xFF) + chr(msg[i] >> 8 & 0xFF) + chr(msg[i] >> 16 & 0xFF) + chr(msg[i] >> 24 & 0xFF)
                    for i in range(l)
                ]
                return ''.join(msg_chars)[:ll] if key else ''.join(msg_chars)

            if msg == '':
                return ''
            pwd = sencode(msg, True)
            pwdk = sencode(key, False)
            if len(pwdk) < 4:
                pwdk = pwdk + [0] * (4 - len(pwdk))
            n = len(pwd) - 1
            z = pwd[n]
            y = pwd[0]
            c = 0x86014019 | 0x183639A0
            m = 0
            e = 0
            p = 0
            q = math.floor(6 + 52 / (n + 1))
            d = 0
            while 0 < q:
                d = d + c & (0x8CE0D9BF | 0x731F2640)
                e = d >> 2 & 3
                p = 0
                while p < n:
                    y = pwd[p + 1]
                    m = z >> 5 ^ y << 2
                    m = m + ((y >> 3 ^ z << 4) ^ (d ^ y))
                    m = m + (pwdk[(p & 3) ^ e] ^ z)
                    pwd[p] = pwd[p] + m & (0xEFB8D130 | 0x10472ECF)
                    z = pwd[p]
                    p += 1
                y = pwd[0]
                m = z >> 5 ^ y << 2
                m = m + ((y >> 3 ^ z << 4) ^ (d ^ y))
                m = m + (pwdk[(p & 3) ^ e] ^ z)
                pwd[n] = pwd[n] + m & (0xBB390742 | 0x44C6F8BD)
                z = pwd[n]
                q = q - 1
            return lencode(pwd, False) or ''

        class Base64:
            STANDARD = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
            ALPHA = 'LVoJPiCN2R8G90yg+hmFHuacZ1OWMnrsSTXkYpUq/3dlbfKwv6xztjI7DeBE45QA'

            @staticmethod
            # def encode(raw_s: str) -> str:
            def encode(raw_s):  # type: (str) -> str
                trans = str.maketrans(
                    Base64.STANDARD,
                    Base64.ALPHA,
                )
                ret = b64encode(bytes(ord(i) & 0xFF for i in raw_s))
                return ret.decode().translate(trans)

        json_info = json.dumps(info, separators=(',', ':'))
        return '{SRBX1}' + Base64.encode(encode(json_info, token))

    @staticmethod
    # def parse_jsonp_response(jsonp_res: str) -> 'dict[str, Any]':
    def parse_jsonp_response(jsonp_res):  # type: (str) -> 'dict'
        prefix = FAKE_CALLBACK_NAME + '('
        start_index = jsonp_res.find(prefix) + len(prefix)
        end_index = jsonp_res.rfind(')')
        json_data = jsonp_res[start_index:end_index]
        return json.loads(json_data)

    @staticmethod
    # def is_status_online(status: APIStatusResponseOnline | APIStatusResponseOffline) -> bool:
    def is_status_online(status):  # type: (dict) -> bool
        if 'error' in status and status['error'] == 'ok':
            return True
        return False

    @staticmethod
    # def is_status_offline(status: APIStatusResponseOnline | APIStatusResponseOffline) -> bool:
    def is_status_offline(status):  # type: (dict) -> bool
        if 'error' in status and status['error'] == 'not_online_error':
            return True
        return False


class Portal:
    # __config: Config

    def __init__(self):
        self.__config = self.__get_config()

    @property
    # def config(self) -> Config:
    def config(self):  # type: () -> dict
        return self.__config

    @property
    # def userDevice(self) -> UserDevice:
    def userDevice(self):  # type: () -> dict
        return {'device': 'Linux', 'platform': 'Linux'}

    @property
    # def portal_info(self) -> PortalInfo:
    def portal_info(self):  # type: () -> dict
        return self.__get_portal_info()

    # def get_user_info(self, username: str, password: str) -> UserInfo:
    def get_user_info(self, username, password):  # type: (str, str) -> dict
        config = self.__config
        # return UserInfo(
        #     ip=config['ip'],
        #     mac=config['mac'],
        #     domain='',
        #     username=username,
        #     password=password,
        # )
        return {
            'ip': config['ip'],
            'mac': config['mac'],
            'domain': '',
            'username': username,
            'password': password,
        }

    # def __get_portal_html(self) -> str:
    def __get_portal_html(self):  # type: () -> str
        '''è·å–åŒ—äº¬å¸ˆèŒƒå¤§å­¦è®¤è¯ç½‘å…³å…¥å£é¡µçš„ HTML å­—ç¬¦ä¸²

        Returns:
            str: åŒ—äº¬å¸ˆèŒƒå¤§å­¦è®¤è¯ç½‘å…³å…¥å£é¡µçš„ HTML å­—ç¬¦ä¸²
        '''

        class RedirectParser(HTMLParser):

            def __init__(self):
                super().__init__()
                self.redirect_url = None

            def handle_starttag(self, tag, attrs):
                if tag == 'meta':
                    attrs_dict = dict(attrs)
                    httpEquiv = attrs_dict.get('http-equiv')
                    if httpEquiv is not None and httpEquiv.lower() == 'refresh':
                        content = attrs_dict.get('content')
                        if content is not None:
                            url = content.split(';url=')[1]
                            self.redirect_url = url

        class RedirectHandler(HTTPRedirectHandler):

            def http_error_302(self, req, fp, code, msg, headers):
                return HTTPRedirectHandler.http_error_302(self, req, fp, code, msg, headers)

        opener = build_opener(RedirectHandler())
        response = opener.open(PORTAL_URL)
        parser = RedirectParser()
        parser.feed(response.read().decode('utf-8'))
        redirect_url = parser.redirect_url
        full_redirect_url = urljoin(response.url, redirect_url)
        response = urlopen(full_redirect_url)
        return response.read().decode('utf-8')

    # def __get_config(self) -> Config:
    def __get_config(self):  # type: () -> dict
        html_text = self.__get_portal_html()
        # æå– config éƒ¨åˆ†
        config_match = re.search(r'var\s+CONFIG\s*=\s*({.*?});', html_text, re.DOTALL)
        if config_match is None:
            raise ValueError('CONFIG è§£æå¤±è´¥')
        config_text = config_match[1]

        # æ›¿æ¢ JavaScript çš„å¸ƒå°”å€¼å’Œå­—ç¬¦ä¸²
        config_text = re.sub(r'([^"\r\n\s]+?)\s+:', r'"\1":', config_text)
        config_text = re.sub(r'false', r'False', config_text)
        config_text = re.sub(r'true', r'True', config_text)
        config_text = re.sub(r'\|\|', r' or ', config_text)

        # return Config(eval(config_text))
        return eval(config_text)

    # def __get_portal_info(self) -> PortalInfo:
    def __get_portal_info(self):  # type: () -> dict
        config = self.__config
        # return PortalInfo(
        #     nasIp=config['nas'],
        #     lang=config['lang'],
        #     acid=config['acid'],
        #     flowMode=config['portal']['TrafficCarry'] if 'TrafficCarry' in config['portal'] else 1024,
        #     nowType='ipv6' if config['isIPV6'] else 'ipv4',
        #     ipv4=config['portal']['AuthIP'],
        #     ipv6=config['portal']['AuthIP6'],
        #     doub=False,
        #     userDevice=self.userDevice,
        #     selfServiceIp=config['portal']['ServiceIP'],
        #     noticeType=config['notice'],
        # )
        return {
            'nasIp': config['nas'],
            'lang': config['lang'],
            'acid': config['acid'],
            'flowMode': config['portal']['TrafficCarry'] if 'TrafficCarry' in config['portal'] else 1024,
            'nowType': 'ipv6' if config['isIPV6'] else 'ipv4',
            'ipv4': config['portal']['AuthIP'],
            'ipv6': config['portal']['AuthIP6'],
            'doub': False,
            'userDevice': self.userDevice,
            'selfServiceIp': config['portal']['ServiceIP'],
            'noticeType': config['notice'],
        }

    # def get_status(self) -> 'APIStatusResponseOnline | APIStatusResponseOffline':
    def get_status(self):  # type: () -> dict
        '''è·å– IP çŠ¶æ€'''
        ip = self.config['ip']
        query_dict = {'ip': ip}
        url = API_STATUS_URL + '?' + Utils.query_dict_to_string(query_dict)
        try:
            response = urlopen(url)
            jsonp_resp = response.read().decode('utf-8')
            resp = Utils.parse_jsonp_response(jsonp_resp)

            # if Utils.is_status_online(cast(Any, resp)):
            #     return APIStatusResponseOnline(**resp)
            # elif Utils.is_status_offline(cast(Any, resp)):
            #     return APIStatusResponseOffline(**resp)
            if Utils.is_status_online(resp):
                return resp
            elif Utils.is_status_offline(resp):
                return resp
            else:
                raise StatusError('Portal.get_status: æœªé¢„æœŸçš„çŠ¶æ€ã€‚\næœåŠ¡å™¨çŠ¶æ€: ' + str(resp))

        except URLError as e:
            raise ConnectionError('Portal.get_status: æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ã€‚URL é”™è¯¯: ' + str(e)) from e

        except Exception as e:
            raise RuntimeError('Portal.get_status: æœªé¢„æœŸçš„é”™è¯¯: ' + str(e)) from e

    # def print_status(self, status: 'APIStatusResponseOnline | APIStatusResponseOffline | None' = None):
    def print_status(self, status=None):  # type: (dict | None) -> None
        '''æ‰“å° IP çŠ¶æ€

        Args:
            status (APIStatusResponseOnline | APIStatusResponseOffline | None, optional): IP çŠ¶æ€ã€‚é»˜è®¤ä¸º Noneï¼Œæ­¤æ—¶ä¼šè‡ªåŠ¨è·å– IP çŠ¶æ€ã€‚
        '''
        if status is None:
            status = self.get_status()
        if Utils.is_status_online(status):
            # status = cast(APIStatusResponseOnline, status)
            print(GREEN + 'ğŸŒ IP çŠ¶æ€' + RESET, 'åœ¨çº¿')
            print(GREEN + 'ğŸ‘¤ ç”¨æˆ·è´¦å·' + RESET, status['user_name'])
            print(GREEN + 'ğŸ“ˆ å·²ç”¨æµé‡' + RESET, str(round(status['sum_bytes'] / (1024**3), 2)) + ' GB')
            hours = status['sum_seconds'] // 3600
            minutes = (status['sum_seconds'] % 3600) // 60
            seconds = status['sum_seconds'] % 60
            print(GREEN + 'â³ å·²ç”¨æ—¶é•¿' + RESET, str(hours) + 'å°æ—¶' + str(minutes) + 'åˆ†' + str(seconds) + 'ç§’')
            print(GREEN + 'ğŸ’µ è´¦æˆ·ä½™é¢' + RESET, round(status['user_balance'], 2))
            print(GREEN + 'ğŸ“ IP åœ°å€' + RESET, status['online_ip'])
            print(GREEN + 'ğŸ“– äº§å“åç§°' + RESET, status['products_name'])
        elif Utils.is_status_offline(status):
            # status = cast(APIStatusResponseOffline, status)
            print(RED + 'ğŸ’¤ IP çŠ¶æ€' + RESET, 'ç¦»çº¿')
            print(RED + 'ğŸ“ IP åœ°å€' + RESET, status['online_ip'])
        else:
            print(RED + 'ğŸš« æ— æ³•è§£æçŠ¶æ€ä¿¡æ¯ã€‚' + RESET)

    def logout(self):
        status = self.get_status()
        if Utils.is_status_offline(status):
            # å¦‚æœå·²ç»ç¦»çº¿ï¼Œåˆ™ä¸éœ€è¦æ³¨é”€
            print(YELLOW + 'ğŸ’¤ IP çŠ¶æ€ä¸ºç¦»çº¿ï¼Œæ— éœ€æ³¨é”€' + RESET)
            return
        # status = cast(APIStatusResponseOnline, status)
        ip = status['online_ip']
        username = status['user_name']
        ac_id = self.config['acid']
        query_dict = {
            'action': 'logout',
            'username': username,
            'ip': ip,
            'ac_id': ac_id,
        }
        url = API_RUN_URL + '?' + Utils.query_dict_to_string(query_dict)
        try:
            response = urlopen(url)
            jsonp_resp = response.read().decode('utf-8')
            # resp = APILogoutResponse(**Utils.parse_jsonp_response(jsonp_resp))
            resp = Utils.parse_jsonp_response(jsonp_resp)

            if resp['error'] == 'ok' and resp['res'] == 'ok':
                while True:
                    status = self.get_status()
                    if Utils.is_status_offline(status):
                        break
                    # formated current time
                    current_time = time.localtime(time.time())
                    t = time.strftime('%Y-%m-%d %H:%M:%S', current_time)
                    print(YELLOW + 'ğŸ’¤ IP çŠ¶æ€ä¸ºåœ¨çº¿ï¼Œç­‰å¾…æ³¨é”€' + ' (' + t + ')' + RESET)
                    time.sleep(1)
                print(GREEN + 'ğŸ‘¤ ç”¨æˆ·è´¦å·', username, 'å·²æ³¨é”€' + ' (' + Utils.get_formatted_date_and_time() + ')' + RESET)
                print(GREEN + 'ğŸ“ IP åœ°å€', ip + RESET)

        except URLError as e:
            raise ConnectionError('Portal.logout: æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ã€‚URL é”™è¯¯: ' + str(e)) from e

        except Exception as e:
            raise RuntimeError('Portal.logout: æœªé¢„æœŸçš„é”™è¯¯: ' + str(e)) from e


class Authenticator:
    # __user_info: UserInfo
    # __portal_info: PortalInfo

    # def __init__(self, user_info: UserInfo, portal_info: PortalInfo):
    def __init__(self, user_info, portal_info):  # type: (dict, dict) -> None
        self.__user_info = user_info
        self.__portal_info = portal_info

    @property
    # def user_info(self) -> UserInfo:
    def user_info(self):  # type: () -> dict
        return self.__user_info

    @property
    # def portal_info(self) -> PortalInfo:
    def portal_info(self):  # type: () -> dict
        return self.__portal_info

    def __get_token(self) -> str:
        '''è·å–æœ€æ–°çš„ tokenã€‚å› ä¸º token æœ‰æ—¶æ•ˆæ€§ï¼Œæ‰€ä»¥æ¯æ¬¡è®¤è¯éƒ½éœ€è¦è·å–æœ€æ–°çš„ tokenã€‚'''
        ip = self.user_info['ip']
        params = {
            'username': self.user_info['username'],
            'ip': ip,
        }
        url = API_TOKEN_URL + '?' + Utils.query_dict_to_string(params)

        try:
            response = urlopen(url)
            jsonp_resp: str = response.read().decode('utf-8')
            # resp = APITokenResponse(**Utils.parse_jsonp_response(jsonp_resp))
            resp = Utils.parse_jsonp_response(jsonp_resp)

            if 'challenge' not in resp:
                raise TokenRetrievalError('Authenticator.__get_token: æœåŠ¡å™¨å“åº”æ— æ•ˆï¼Œç¼ºå°‘ challenge å­—æ®µã€‚\næœåŠ¡å™¨å“åº”: ' + str(resp))

            challenge = resp['challenge']
            client_ip = resp['client_ip']
            error = resp.get('error', '')
            error_msg = resp.get('error_msg', '')
            res = resp.get('res', '')

            if error == 'ok' and res == 'ok' and client_ip == ip:
                return challenge
            if error_msg:
                raise TokenRetrievalError('Authenticator.__get_token: ' + error_msg + '\næœåŠ¡å™¨å“åº”: ' + str(resp))
            raise TokenRetrievalError('Authenticator.__get_token: æ— æ•ˆçš„å“åº”æˆ–å‘ç”Ÿé”™è¯¯ã€‚\næœåŠ¡å™¨å“åº”: ' + str(resp))

        except URLError as e:
            raise TokenRetrievalError('Authenticator.__get_token: æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨: ' + str(e)) from e

        except json.JSONDecodeError as e:
            raise TokenRetrievalError('Authenticator.__get_token: æ— æ³•è§£ææœåŠ¡å™¨å“åº”ã€‚') from e

        except Exception as e:
            raise TokenRetrievalError('Authenticator.__get_token: å‘ç”Ÿé”™è¯¯: ' + str(e)) from e

    def login(self):
        user_info = self.user_info
        portal_info = self.portal_info
        token = self.__get_token()
        # åŠ å¯†å¸¸é‡
        TYPE = 1
        N = 200
        ENC = 'srun_bx1'

        username = user_info['username']
        password = user_info['password']
        ip = user_info['ip']

        ac_id = portal_info['acid']
        nowType = portal_info['nowType']
        ipv4 = portal_info['ipv4']
        ipv6 = portal_info['ipv6']
        host = ipv4 if nowType == 'ipv4' else ipv6

        hmd5 = Utils.md5(password, token)
        i = Utils.encode_user_info({
            'username': username,
            'password': password,
            'ip': ip,
            'acid': ac_id,
            'enc_ver': ENC
        }, token)

        chksum_str = token + username + token + hmd5 + token + ac_id + token + ip + token + str(N) + token + str(
            TYPE) + token + i
        chksum = hashlib.sha1(chksum_str.encode()).hexdigest()

        # authQueryDict = APIRunQueryDictLogin(
        #     action='login',
        #     username=username,
        #     password='{MD5}' + hmd5,
        #     os=portal_info['userDevice']['device'],
        #     name=portal_info['userDevice']['platform'],
        #     double_stack=0,
        #     chksum=chksum,
        #     info=i,
        #     ac_id=ac_id,
        #     ip=ip,
        #     n=N,
        #     type=TYPE,
        # )
        authQueryDict = {
            'action': 'login',
            'username': username,
            'password': '{MD5}' + hmd5,
            'os': portal_info['userDevice']['device'],
            'name': portal_info['userDevice']['platform'],
            'double_stack': 0,
            'chksum': chksum,
            'info': i,
            'ac_id': ac_id,
            'ip': ip,
            'n': N,
            'type': TYPE,
        }

        try:
            # def __send_auth(authParams: dict[Unknown, Unknown]) -> (APIAuthResponseLoginOk | APIAuthResponseIpAlreadyOnlineError | APIAuthResponseLoginError)
            resp = self.__authenticate(authQueryDict)
        except URLError as e:
            print(RED + 'ğŸš« æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨: ' + RESET + str(e))

        except json.JSONDecodeError as e:
            print(RED + 'ğŸš« æ— æ³•è§£ææœåŠ¡å™¨å“åº”ã€‚' + RESET)

        except Exception as e:
            print(RED + 'ğŸš« å‘ç”Ÿé”™è¯¯: ' + RESET + str(e))

    # def __authenticate(self, authQueryDict: APIRunQueryDictLogin) -> None:
    def __authenticate(self, authQueryDict):  # type: (dict) -> None
        url = API_RUN_URL + '?' + Utils.query_dict_to_string(authQueryDict)
        response = urlopen(url)
        jsonp_resp = response.read().decode('utf-8')
        resp = Utils.parse_jsonp_response(jsonp_resp)

        if resp['error'] == 'ok' and 'suc_msg' in resp and resp['suc_msg'] == 'login_ok':
            # Handle login OK
            # resp = APIAuthResponseLoginOk(**resp)
            print(GREEN + 'ğŸ‰ è®¤è¯æˆåŠŸï¼' + ' (' + Utils.get_formatted_date_and_time() + ')' + RESET)
            return
        elif resp['error'] == 'ok' and 'suc_msg' in resp and resp['suc_msg'] == 'ip_already_online_error':
            # Handle IP already online error
            # resp = APIAuthResponseIpAlreadyOnlineError(**resp)
            print(GREEN + 'ğŸ¤” IP å·²åœ¨çº¿ï¼Œæ— éœ€é‡å¤è®¤è¯ã€‚' + ' (' + Utils.get_formatted_date_and_time() + ')' + RESET)
            return
        elif resp['error'] == 'login_error':
            # Handle login error
            # resp = APIAuthResponseLoginError(**resp)
            print(RED + 'ğŸ˜­ è®¤è¯å¤±è´¥ï¼Œé”™è¯¯ä¿¡æ¯: ' + resp['error_msg'] + ' (' + Utils.get_formatted_date_and_time() + ')' + RESET)
            return
        raise AuthError('Authenticator.__send_auth: æ— æ•ˆçš„å“åº”ã€‚\næœåŠ¡å™¨å“åº”: ' + str(resp))


if __name__ == '__main__':
    # åˆ›å»ºå‘½ä»¤è¡Œå‚æ•°è§£æå™¨
    parser = argparse.ArgumentParser(description='åŒ—äº¬å¸ˆèŒƒå¤§å­¦æ ¡å›­ç½‘å‘½ä»¤è¡Œå®¢æˆ·ç«¯ (ä½œè€…: Zhaoji Wang <zhaoji.wang@mail.bnu.edu.cn>)')
    parser.add_argument('-v', '--version', action='version', version='%(prog)s ' + VERSION)
    subparsers = parser.add_subparsers(dest='command')

    # åˆ›å»ºâ€œstatusâ€å­å‘½ä»¤
    status_parser = subparsers.add_parser('status', help='æŸ¥è¯¢ IP çŠ¶æ€')
    # åˆ›å»ºâ€œloginâ€å­å‘½ä»¤
    login_parser = subparsers.add_parser('login', help='ç™»å½•')
    login_parser.add_argument('-u', '--username', type=str, help='ç”¨æˆ·è´¦å·')
    login_parser.add_argument('-p', '--password', type=str, help='æ ¡å›­ç½‘ç™»å½•å¯†ç ')
    # åˆ›å»ºâ€œlogoutâ€å­å‘½ä»¤
    logout_parser = subparsers.add_parser('logout', help='æ³¨é”€')

    # è·å–ç¨‹åºåç§°
    prog = parser.prog
    # è§£æå‘½ä»¤è¡Œå‚æ•°
    args = parser.parse_args()

    if args.command == 'status':
        portal = Portal()
        portal.print_status()
    elif args.command == 'login':
        # ä½¿ç”¨é¢œè‰²å’Œ Emoji æç¤º
        prompt_username = GREEN + 'ğŸ”‘ è¯·è¾“å…¥ç”¨æˆ·è´¦å·: ' + RESET
        prompt_password = GREEN + 'ğŸ”’ è¯·è¾“å…¥æ ¡å›­ç½‘ç™»å½•å¯†ç : ' + RESET

        # è·å–ç”¨æˆ·åå’Œå¯†ç 
        username: str = args.username or ''
        password: str = args.password or ''
        while not username:
            username = input(prompt_username)
        while not password:
            password = getpass(prompt_password)
        if not username or not password:  # ç†è®ºä¸Šä¸ä¼šå‡ºç°è¿™ç§æƒ…å†µ
            raise ValueError('ç”¨æˆ·åæˆ–å¯†ç ä¸èƒ½ä¸ºç©º')

        portal = Portal()
        user_info = portal.get_user_info(username, password)
        authenticator = Authenticator(user_info, portal.portal_info)
        authenticator.login()
        print()
        portal.print_status()
    elif args.command == 'logout':
        portal = Portal()
        portal.logout()
    elif args.command is None:
        # æ‰“å°å¸®åŠ©ä¿¡æ¯
        parser.print_help()

        # æ‰“å°ç¤ºä¾‹
        print()
        print('è°ƒç”¨ç¤ºä¾‹:\n')
        print('  ' + prog + GREEN + ' status' + RESET + '   ')
        print('  ' + prog + GREEN + ' login' + RESET + '   ')
        print('  ' + prog + GREEN + ' login' + RESET + ' [' + YELLOW + '-u' + RESET + ' ç”¨æˆ·è´¦å·]' + ' [' + YELLOW + '-p' +
              RESET + ' æ ¡å›­ç½‘ç™»å½•å¯†ç ]' + '   ')
        print('  ' + prog + GREEN + ' logout' + RESET + '   ')

        # æ·»åŠ é¢å¤–çš„è¯´æ˜
        print()
        print('æ³¨æ„äº‹é¡¹:\n')
        print('  - ä½¿ç”¨ ' + GREEN + 'status' + RESET + ' å‘½ä»¤ä¼šæ˜¾ç¤ºè¯¥ IP å½“å‰çš„æ ¡å›­ç½‘è¿æ¥çŠ¶æ€')
        print('  - ä½¿ç”¨ ' + GREEN + 'login' + RESET + ' å‘½ä»¤å°†è¯¥ IP è¿æ¥åˆ°æ ¡å›­ç½‘')
        print('      ' + YELLOW + '-u' + RESET + ' åé¢è·Ÿçš„æ˜¯ä½ çš„ç”¨æˆ·è´¦å·ï¼Œé€šå¸¸æ˜¯å­¦å·ï¼ˆè¯¥å‚æ•°å¯é€‰ï¼‰')
        print('      ' + YELLOW + '-p' + RESET + ' åé¢è·Ÿçš„æ˜¯ä½ çš„æ ¡å›­ç½‘ç™»å½•å¯†ç ï¼ˆè¯¥å‚æ•°å¯é€‰ï¼‰')
        print('      ' + 'å¦‚æœä¸æŒ‡å®š ' + YELLOW + '-u' + RESET + ' å’Œ ' + YELLOW + '-p' + RESET + ' å‚æ•°ï¼Œç¨‹åºä¼šæç¤ºä½ äº¤äº’å¼è¾“å…¥è´¦å·å’Œå¯†ç ')
        print('  - ä½¿ç”¨ ' + GREEN + 'logout' + RESET + ' å‘½ä»¤ä¼šæ–­å¼€è¯¥ IP å½“å‰çš„æ ¡å›­ç½‘è¿æ¥')
    else:
        parser.print_help()
